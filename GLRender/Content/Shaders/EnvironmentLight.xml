<?xml version='1.0' encoding='us-ascii'?>
<shader version="400">
  <include>DeferredCommon</include>
  <include>Colorspace</include>
  <include>BRDFs</include>
  <vertexshader>
    <input type="vec3" location="0">position</input>
    <input type="vec2" location="1">uv</input>
    <uniform type="mat4">proj</uniform>
    <uniform type="mat4">view</uniform>
    <uniform type="vec3">eyePos</uniform>
    <output type="vec2">f_uv</output>
    <output type="vec3">f_eyeVec</output>
    <source>
      f_uv = uv;
      f_eyeVec = normalize(position - eyePos);
      gl_Position = proj * view * vec4(position, 1.0);
    </source>
  </vertexshader>
  <fragmentshader>
    <input type="vec2">f_uv</input>
    <input type="vec3">f_eyeVec</input>
    <uniform type="samplerCube">cubeMap</uniform>
    <uniform type="float">intensity</uniform>
    <output type="vec4">fragColor</output>
    <source>
      GBufferData data = ReadGBuffer(f_uv);

      vec3 V = normalize(-f_eyeVec);
      vec3 diffL = data.Normal;
      vec3 specL = reflect(-V, data.Normal);
      vec3 diffH = normalize(V + diffL);
      vec3 specH = normalize(V + specL);

      vec3 diffuseLightColor = textureLod(cubeMap, diffL, 10.0).rgb;
      vec3 specularLightColor = textureLod(cubeMap, specL, data.Roughness * 10.0).rgb;

      float NoV = saturate(dot(data.Normal, V));

      vec3 DiffuseColor = data.Color - data.Color * data.Metallicity;
      vec3 f0 = mix( vec3(0.04), data.Color, data.Metallicity );

      float specLoH = saturate(dot(specL, specH));
      float specNoL = saturate(dot(data.Normal, specL));
      float specNoH = 1.0;
      //vec3 F = F_Schlick(f0, specLoH);
      //float G = Vis_Schlick(data.Roughness, NoV, specNoL);
      //float D = D_Beckmann(data.Roughness, specNoH);

      //vec3 specular = (F * G * D);
      vec3 specular = F_Schlick(f0, specLoH) * (1.0 - data.Roughness);

      float diffVoL = saturate(dot(V, diffL));
      float diffVoH = saturate(dot(V, diffH));
      vec3 diffuse = Diffuse_OrenNayar(DiffuseColor, data.Roughness, diffVoL, NoV, 1.0, diffVoH);

      vec3 preGamma = ((diffuse * diffuseLightColor) + (specular * specularLightColor)) * intensity;
      vec3 postGamma = gammaCorrect(preGamma);
      fragColor = vec4(postGamma, 1);
      //fragColor = vec4(vec3(data.Roughness), 1);
      //fragColor = vec4(diffuse * diffuseLightColor, 1);
      //fragColor = vec4(vec3(D), 1);
    </source>
  </fragmentshader>
</shader>
