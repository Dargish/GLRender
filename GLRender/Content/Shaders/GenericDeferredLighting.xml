<?xml version='1.0' encoding='us-ascii'?>
<shader version="400">
  <include>DeferredCommon</include>
  <include>Colorspace</include>
  <include>BRDFs</include>
	<vertexshader>
		<input type="vec3" location="0">position</input>
		<input type="vec2" location="1">uv</input>
    <uniform type="mat4">proj</uniform>
    <uniform type="mat4">view</uniform>
    <uniform type="vec3">eyePos</uniform>
		<output type="vec2">f_uv</output>
    <output type="vec3">f_eyeVec</output>
		<source>
      f_uv = uv;
      f_eyeVec = normalize(position - eyePos);
      gl_Position = proj * view * vec4(position, 1.0);
    </source>
	</vertexshader>
	<fragmentshader>
		<input type="vec2">uv</input>
    <input type="vec3">eyeVec</input>
		<uniform type="vec3">direction</uniform>
		<uniform type="vec3">color</uniform>
		<uniform type="float">intensity</uniform>
		<output type="vec4">fragColor</output>
		<source>
      GBufferData data = ReadGBuffer(uv);

      vec3 V = normalize(-eyeVec);
      vec3 L = normalize(-direction);
      vec3 H = normalize(V + L);

      float VoL = saturate(dot(V, L));
      float NoV = saturate(dot(data.Normal, V));
      float VoH = saturate(dot(V, H));
      float NoH = saturate(dot(data.Normal, H));
      float NoL = saturate(dot(data.Normal, L));
      float LoH = saturate(dot(L, H));

      vec3 DiffuseColor = data.Color - data.Color * data.Metallicity;
      vec3 f0 = mix( vec3(0.04), data.Color, data.Metallicity );

      vec3 F = F_Schlick(f0, LoH);
      float G = Vis_Schlick(data.Roughness, NoV, NoL);
      float D = D_GGX(data.Roughness, NoH);

      vec3 specular = (F * G * D) * NoL;// / (4*NoL*NoV);
      vec3 diffuse = Diffuse_OrenNayar(DiffuseColor, data.Roughness, VoL, NoV, NoL, VoH);

      vec3 preGamma = (diffuse + specular) * intensity * color;
      vec3 postGamma = gammaCorrect(preGamma);
      fragColor = vec4(postGamma, 1);
    </source>
	</fragmentshader>
</shader>
